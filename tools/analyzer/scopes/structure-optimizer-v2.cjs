#!/usr/bin/env node

/**
 * üèóÔ∏è STRUCTURE-OPTIMIZER v2.0 (HANG-SICHER + SCHNELL)
 *
 * üéØ ZWECK: Projekt-Struktur bewerten & Umzugspl√§ne mit Link-Mapping erstellen
 * üöÄ OPTIMIERT: Keine Endlosschleifen, schnelle Verarbeitung
 * üîó LINK-MAPPING: Alte ‚Üí Neue Pfade f√ºr automatische KI-Umsetzung
 * üìã INVENTARISIERUNG: Vollst√§ndige Datei-Kategorisierung
 */

const fs = require("fs").promises;
const path = require("path");

class StructureOptimizerV2 {
  constructor() {
    this.results = {
      currentStructure: {},
      movementPlan: [],
      linkMappings: [],
      migrationScript: [],
      statistics: {},
      recommendations: [],
    };

    // Vereinfachte Ziel-Strukturen
    this.targetStructures = {
      // Archive-Kategorien (hohe Priorit√§t)
      archive_candidates: {
        patterns: [
          /backup|old|alt|deprecated|chaos|temp|tmp/i,
          /\d{4}-\d{2}-\d{2}/,
        ],
        target: "docs/archive/auto-cleanup-2025-07-25/",
        priority: "HIGH",
      },

      // Leere Dateien (sofort l√∂schbar)
      empty_files: {
        patterns: [/\.md$|\.txt$/],
        condition: "empty",
        target: "DELETE",
        priority: "IMMEDIATE",
      },

      // Dokumentation strukturieren
      documentation: {
        patterns: [/\.md$/, /docs\//],
        target: "docs/organized/",
        priority: "MEDIUM",
      },

      // Tools konsolidieren
      tools: {
        patterns: [/\.cjs$|\.js$|\.ps1$/],
        target: "tools/consolidated/",
        priority: "MEDIUM",
      },
    };

    // Gesch√ºtzte Dateien (nie verschieben)
    this.protectedFiles = [
      /\.github\/copilot-instructions/,
      /src\//,
      /public\//,
      /node_modules/,
      /\.git/,
      /package\.json$/,
      /astro\.config/,
      /tailwind\.config/,
      /tools\/analyzer\/.*\.cjs$/,
    ];
  }

  /**
   * üöÄ HAUPT-STRUKTUR-OPTIMIERUNG
   */
  async optimizeStructure(projectRoot) {
    console.log("üèóÔ∏è STRUCTURE-OPTIMIZER v2.0: Starte schnelle Analyse...");

    try {
      // 1. Schnelle Datei-Inventarisierung
      const allFiles = await this.quickInventory(projectRoot);
      console.log(`üìÅ ${allFiles.length} Dateien gefunden`);

      // 2. Kategorisierung ohne komplexe Analyse
      await this.categorizeFiles(allFiles, projectRoot);
      console.log("üìã Dateien kategorisiert");

      // 3. Umzugspl√§ne generieren
      await this.generateMovementPlans(allFiles, projectRoot);
      console.log("üöõ Umzugspl√§ne erstellt");

      // 4. Link-Mappings (vereinfacht)
      await this.createSimpleLinkMappings();
      console.log("üîó Link-Mappings generiert");

      // 5. Migration-Scripts
      await this.generateMigrationScript(projectRoot);
      console.log("üìú Migration-Script erstellt");

      return this.generateFinalReport();
    } catch (error) {
      console.error("‚ùå Structure-Optimizer Fehler:", error.message);
      throw error;
    }
  }

  /**
   * üìÅ SCHNELLE DATEI-INVENTARISIERUNG
   */
  async quickInventory(projectRoot) {
    const files = [];

    await this.quickWalk(projectRoot, files, 0);

    return files.map((filePath) => ({
      path: filePath,
      relativePath: path.relative(projectRoot, filePath),
      name: path.basename(filePath),
      ext: path.extname(filePath),
      dir: path.dirname(path.relative(projectRoot, filePath)),
    }));
  }

  /**
   * üö∂ SCHNELLER VERZEICHNIS-DURCHLAUF (mit Tiefenbegrenzung)
   * üö® SIMON'S TABU-VERZEICHNISSE: .astro, .vscode, node_modules
   */
  async quickWalk(dir, files, depth) {
    if (depth > 10) return; // Tiefenbegrenzung gegen Endlosschleifen

    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        // üö® SIMON'S ERWEITERTE TABU-LISTE
        if (this.shouldIgnoreDirectory(entry.name)) continue;
        
        const fullPath = path.join(dir, entry.name);

        if (entry.isDirectory()) {
          await this.quickWalk(fullPath, files, depth + 1);
        } else if (entry.isFile()) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      // Verzeichnis nicht zug√§nglich - √ºberspringen
    }
  }

  /**
   * üö´ SIMON'S TABU-VERZEICHNISSE (ABSOLUTES VERBOT)
   */
  shouldIgnoreDirectory(name) {
    const SIMON_TABU_DIRS = [
      '.astro',         // üö® Astro Build-Cache  
      '.vscode',        // üö® VS Code Settings
      'node_modules',   // üö® NPM Dependencies
      '.git',           // Git Repository
      'dist',           // Build Output
      'build',          // Build Output
      '.next',          // Next.js Cache
      '.cache',         // Generic Cache
    ];

    // Exakte √úbereinstimmung ODER Pattern-Match
    return SIMON_TABU_DIRS.includes(name) || 
           name.startsWith('.') && name !== '.github';
  }

  /**
   * üìã DATEI-KATEGORISIERUNG
   */
  async categorizeFiles(files, projectRoot) {
    for (const file of files) {
      // Gesch√ºtzte Dateien √ºberspringen
      if (this.isProtectedFile(file.relativePath)) {
        continue;
      }

      // Dateigr√∂√üe pr√ºfen f√ºr leere Dateien
      try {
        const stats = await fs.stat(path.join(projectRoot, file.relativePath));
        file.size = stats.size;
        file.isEmpty = stats.size === 0;
        file.modified = stats.mtime;
      } catch (error) {
        file.size = -1;
        file.isEmpty = false;
      }

      // Kategorie basierend auf Pattern bestimmen
      file.category = this.determineCategory(file);
      file.targetStructure = this.determineTarget(file);
    }
  }

  /**
   * üõ°Ô∏è GESCH√úTZTE DATEI PR√úFEN
   */
  isProtectedFile(relativePath) {
    return this.protectedFiles.some((pattern) => pattern.test(relativePath));
  }

  /**
   * üìÇ KATEGORIE BESTIMMEN
   */
  determineCategory(file) {
    const relativePath = file.relativePath;
    const fileName = file.name;

    // Leere Dateien
    if (file.isEmpty) {
      return "empty_files";
    }

    // Archive-Kandidaten
    for (const pattern of this.targetStructures.archive_candidates.patterns) {
      if (pattern.test(relativePath) || pattern.test(fileName)) {
        return "archive_candidates";
      }
    }

    // Dokumentation
    if (file.ext === ".md" || relativePath.includes("docs/")) {
      return "documentation";
    }

    // Tools
    if ([".cjs", ".js", ".ps1", ".bat"].includes(file.ext)) {
      return "tools";
    }

    return "other";
  }

  /**
   * üéØ ZIEL-PFAD BESTIMMEN
   */
  determineTarget(file) {
    const category = file.category;
    const structure = this.targetStructures[category];

    if (!structure) return file.relativePath;

    if (structure.target === "DELETE" && file.isEmpty) {
      return "DELETE";
    }

    if (structure.target) {
      return path.join(structure.target, file.name).replace(/\\/g, "/");
    }

    return file.relativePath;
  }

  /**
   * üöõ UMZUGSPL√ÑNE GENERIEREN
   */
  async generateMovementPlans(files, projectRoot) {
    let movementId = 1;

    for (const file of files) {
      if (file.targetStructure && file.targetStructure !== file.relativePath) {
        const movement = {
          id: movementId++,
          type: file.targetStructure === "DELETE" ? "DELETE" : "MOVE",
          source: file.relativePath,
          target: file.targetStructure,
          category: file.category,
          priority: this.targetStructures[file.category]?.priority || "LOW",
          size: file.size,
          isEmpty: file.isEmpty,
          reason: this.getMovementReason(file),
          risk: this.assessMovementRisk(file),
          migrationCommand: this.generateMovementCommand(file, projectRoot),
        };

        this.results.movementPlan.push(movement);
      }
    }

    // Nach Priorit√§t sortieren
    this.results.movementPlan.sort((a, b) => {
      const priorityOrder = { IMMEDIATE: 1, HIGH: 2, MEDIUM: 3, LOW: 4 };
      return priorityOrder[a.priority] - priorityOrder[b.priority];
    });
  }

  /**
   * üìù BEWEGUNGSGRUND ERMITTELN
   */
  getMovementReason(file) {
    if (file.isEmpty) return "Leere Datei - sicher l√∂schbar";
    if (file.category === "archive_candidates")
      return "Archive/Backup-Pattern erkannt";
    if (file.category === "documentation") return "Dokumentation strukturieren";
    if (file.category === "tools") return "Tools konsolidieren";
    return "Struktur-Optimierung";
  }

  /**
   * ‚ö†Ô∏è BEWEGUNGSRISIKO BEWERTEN
   */
  assessMovementRisk(file) {
    if (file.isEmpty) return "NONE";
    if (file.category === "archive_candidates") return "LOW";
    if (this.isProtectedFile(file.relativePath)) return "HIGH";
    return "MEDIUM";
  }

  /**
   * üíª BEWEGUNGSKOMMANDO GENERIEREN
   */
  generateMovementCommand(file, projectRoot) {
    const sourcePath = path.join(projectRoot, file.relativePath);

    if (file.targetStructure === "DELETE") {
      return `Remove-Item "${sourcePath}" -Force`;
    }

    const targetPath = path.join(projectRoot, file.targetStructure);
    const targetDir = path.dirname(targetPath);

    return [
      `New-Item -ItemType Directory -Path "${targetDir}" -Force`,
      `Move-Item "${sourcePath}" "${targetPath}"`,
    ].join(" ; ");
  }

  /**
   * üîó VEREINFACHTE LINK-MAPPINGS
   */
  async createSimpleLinkMappings() {
    for (const movement of this.results.movementPlan) {
      if (movement.type === "MOVE") {
        const mapping = {
          oldPath: movement.source,
          newPath: movement.target,
          affectedFiles: [], // Vereinfacht - w√ºrde komplexe Suche erfordern
          updateCommands: [
            `# Update Links von: ${movement.source}`,
            `# Zu: ${movement.target}`,
            `# Manuelle √úberpr√ºfung empfohlen`,
          ],
        };

        this.results.linkMappings.push(mapping);
      }
    }
  }

  /**
   * üìú MIGRATION-SCRIPT GENERIEREN
   */
  async generateMigrationScript(projectRoot) {
    const script = [
      "# üöõ STRUKTUR-MIGRATION SCRIPT",
      "# Generiert von Structure-Optimizer v2.0",
      `# Datum: ${new Date().toLocaleDateString("de-DE")}`,
      "",
      "# WICHTIG: Backup erstellen vor Ausf√ºhrung!",
      'Write-Host "üîÑ Starte Struktur-Migration..." -ForegroundColor Green',
      "",
    ];

    // Sofortige Aktionen (DELETE)
    const immediateActions = this.results.movementPlan.filter(
      (m) => m.priority === "IMMEDIATE"
    );
    if (immediateActions.length > 0) {
      script.push("# üóëÔ∏è SOFORTIGE AKTIONEN (Leere Dateien l√∂schen)");
      immediateActions.forEach((action) => {
        script.push(
          `Write-Host "L√∂sche: ${action.source}" -ForegroundColor Yellow`
        );
        script.push(action.migrationCommand);
        script.push("");
      });
    }

    // Archiv-Verschiebungen
    const archiveActions = this.results.movementPlan.filter(
      (m) => m.category === "archive_candidates"
    );
    if (archiveActions.length > 0) {
      script.push("# üì¶ ARCHIV-VERSCHIEBUNGEN");
      archiveActions.slice(0, 10).forEach((action) => {
        // Erste 10
        script.push(
          `Write-Host "Archiviere: ${action.source}" -ForegroundColor Cyan`
        );
        script.push(action.migrationCommand);
        script.push("");
      });
    }

    script.push(
      'Write-Host "‚úÖ Migration abgeschlossen!" -ForegroundColor Green'
    );
    this.results.migrationScript = script;
  }

  /**
   * üìä FINAL-REPORT GENERIEREN
   */
  generateFinalReport() {
    // Statistiken berechnen
    this.results.statistics = {
      totalFiles: this.results.movementPlan.length,
      immediateActions: this.results.movementPlan.filter(
        (m) => m.priority === "IMMEDIATE"
      ).length,
      highPriorityActions: this.results.movementPlan.filter(
        (m) => m.priority === "HIGH"
      ).length,
      mediumPriorityActions: this.results.movementPlan.filter(
        (m) => m.priority === "MEDIUM"
      ).length,
      deleteActions: this.results.movementPlan.filter(
        (m) => m.type === "DELETE"
      ).length,
      moveActions: this.results.movementPlan.filter((m) => m.type === "MOVE")
        .length,
      linkMappings: this.results.linkMappings.length,
    };

    // Empfehlungen
    this.results.recommendations = this.generateRecommendations();

    return {
      summary: {
        status: this.getOverallStatus(),
        ...this.results.statistics,
      },
      movementPlan: this.results.movementPlan.slice(0, 20), // Top 20
      linkMappings: this.results.linkMappings.slice(0, 10), // Top 10
      migrationScript: this.results.migrationScript,
      recommendations: this.results.recommendations,
      nextSteps: this.generateNextSteps(),
    };
  }

  /**
   * üéØ GESAMT-STATUS
   */
  getOverallStatus() {
    const stats = this.results.statistics;

    if (stats.immediateActions > 20) return "AUFR√ÑUMUNG_DRINGEND";
    if (stats.totalFiles > 50) return "STRUKTURIERUNG_ERFORDERLICH";
    if (stats.totalFiles > 10) return "OPTIMIERUNG_M√ñGLICH";
    return "STRUKTUR_OK";
  }

  /**
   * üí° EMPFEHLUNGEN GENERIEREN
   */
  generateRecommendations() {
    const recommendations = [];
    const stats = this.results.statistics;

    if (stats.immediateActions > 0) {
      recommendations.push({
        priority: "SOFORT",
        action: `${stats.immediateActions} leere Dateien l√∂schen`,
        impact: "Sofortige Aufr√§umung ohne Risiko",
        command: "Migration-Script Sektion: SOFORTIGE AKTIONEN",
      });
    }

    if (stats.highPriorityActions > 0) {
      recommendations.push({
        priority: "HEUTE",
        action: `${stats.highPriorityActions} Archive-Kandidaten verschieben`,
        impact: "Projekt-√úbersichtlichkeit deutlich verbessern",
        command: "Migration-Script Sektion: ARCHIV-VERSCHIEBUNGEN",
      });
    }

    if (stats.linkMappings > 0) {
      recommendations.push({
        priority: "NACH_MIGRATION",
        action: "Link-Updates durchf√ºhren",
        impact: "Sicherstellen dass alle Referenzen funktionieren",
        command: "Manuelle Link-√úberpr√ºfung empfohlen",
      });
    }

    return recommendations;
  }

  /**
   * üéØ N√ÑCHSTE SCHRITTE
   */
  generateNextSteps() {
    return [
      {
        step: 1,
        action: "Backup erstellen",
        command: 'git commit -am "Backup vor Struktur-Migration"',
      },
      {
        step: 2,
        action: "Migration-Script ausf√ºhren (Sektion f√ºr Sektion)",
        command: "PowerShell Script aus migrationScript kopieren",
      },
      {
        step: 3,
        action: "Links validieren",
        command: "node tools/analyzer/core/link-validator.cjs",
      },
      {
        step: 4,
        action: "Struktur-Analyse wiederholen",
        command: "node tools/analyzer/scopes/structure-optimizer.cjs",
      },
    ];
  }
}

// Export f√ºr Modul-Verwendung
module.exports = StructureOptimizerV2;

// CLI-Ausf√ºhrung
if (require.main === module) {
  const projectRoot = process.argv[2] || process.cwd();

  const optimizer = new StructureOptimizerV2();
  optimizer
    .optimizeStructure(projectRoot)
    .then((report) => {
      console.log("\nüèóÔ∏è STRUKTUR-OPTIMIERUNG ABGESCHLOSSEN:\n");
      console.log("üìä ZUSAMMENFASSUNG:");
      console.log(`   Status: ${report.summary.status}`);
      console.log(`   Dateien zu bearbeiten: ${report.summary.totalFiles}`);
      console.log(`   Sofortige Aktionen: ${report.summary.immediateActions}`);
      console.log(`   Hohe Priorit√§t: ${report.summary.highPriorityActions}`);
      console.log(`   L√∂sch-Aktionen: ${report.summary.deleteActions}`);
      console.log(`   Verschiebungen: ${report.summary.moveActions}`);

      if (report.recommendations.length > 0) {
        console.log("\nüí° TOP-EMPFEHLUNGEN:");
        report.recommendations.forEach((rec, index) => {
          console.log(`   ${index + 1}. [${rec.priority}] ${rec.action}`);
        });
      }

      if (report.nextSteps.length > 0) {
        console.log("\nüéØ N√ÑCHSTE SCHRITTE:");
        report.nextSteps.forEach((step) => {
          console.log(`   ${step.step}. ${step.action}`);
        });
      }

      console.log("\nüìú Migration-Script wurde generiert!");
      console.log("üìÑ Vollst√§ndiger Report verf√ºgbar.");

      // JSON-Output f√ºr weitere Verarbeitung
      if (process.argv.includes("--json")) {
        console.log("\n" + JSON.stringify(report, null, 2));
      }
    })
    .catch((error) => {
      console.error("‚ùå Struktur-Optimierung Fehler:", error);
      process.exit(1);
    });
}
